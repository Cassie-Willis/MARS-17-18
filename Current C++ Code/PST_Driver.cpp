//
// automatically generated by spin2cpp v3.6.4 on Thu Mar  8 17:13:03 2018
// /home/volsungasaga/Downloads/spin2cpp/build/spin2cpp --gas --side MainFinal (PST_Control).spin 
//

// PST_Driver
// 12/10/2008
// Updated 8/12/2013 to handle Backspace key presses, Cog number designation, and to output characters
// by Gavin Garner and Michael Myers
// University of Virginia
/* 
This program facilitates the use of the Parallax Serial Terminal (PST) with the Propeller chip allowing
a PC (and its keyboard) to communicate with the Propeller and for the Propeller to output text to the computer's
screen. It assumes that the Prop Plug programmer is being used to connect the Propeller to the PC and sets the
baudrate to 115200.

Disclaimer: This program is a modified version of the FullDuplexSerialPlus object by Parallax
that is included in the Objects Lab of their Propeller Education Kit (which is at the time of this initial writing currently still
work in progress) and also borrows methods from the FloatMath object in the Propeller Library. Thus the primary authors of this code
are Jeff Martin, Andy Lindsay, and the almighty Chip Gracey himself. 
 */
#include <stdlib.h>
#include <propeller.h>
#undef clkset
#undef cogid
#undef cogstop
#undef locknew
#undef lockret
#undef lockclr
#undef lockset
#undef waitcnt
#undef waitpeq
#undef waitpne
#define _waitcnt(x) __builtin_propeller_waitcnt((x), 0)
#include "PST_Driver.h"

#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define BitEncode__(X) (32 - __builtin_clz(X))
INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
INLINE__ int32_t Lookup__(int32_t x, int32_t b, int32_t a[], int32_t n) { int32_t i = (x)-(b); return ((unsigned)i >= n) ? 0 : (a)[i]; }

extern char _dat_PST_Driver_[] __asm__("..dat_start");
#define _tostr__(...) #__VA_ARGS__
#define _tostr_(...) _tostr__(__VA_ARGS__)
#define _dat_(...) __asm__(_tostr_(__VA_ARGS__) "\n")
#define _lbl_(x) (x - _org_)
#define _org_ ..dat_start
extern int32_t entry[] __asm__("entry");
_dat_(            .section .PST_Driver.dat,"ax"                       );
_dat_(            .compress off                                       );
_dat_(  ..dat_start:                                                  );
                  // ***********************************
                  // * Assembly language serial driver *
                  // ***********************************
                  // This asynchronous serial communication driver assembly code was written by Chip Gracey et al

#undef _org_
#define _org_ ..org0001
_dat_(..org0001_base = . + 0x0                                        );
_dat_(  entry:                                                        );
                  // get structure address
_dat_(            mov     _lbl_(t1), par                              );
                  // skip past heads and tails
_dat_(            add     _lbl_(t1), #(4 << 2)                        );
                  // get rx_pin
_dat_(            rdlong  _lbl_(t2), _lbl_(t1)                        );
_dat_(            mov     _lbl_(rxmask), #1                           );
_dat_(            shl     _lbl_(rxmask), _lbl_(t2)                    );
                  // get tx_pin
_dat_(            add     _lbl_(t1), #4                               );
_dat_(            rdlong  _lbl_(t2), _lbl_(t1)                        );
_dat_(            mov     _lbl_(txmask), #1                           );
_dat_(            shl     _lbl_(txmask), _lbl_(t2)                    );
                  // get rxtx_mode
_dat_(            add     _lbl_(t1), #4                               );
_dat_(            rdlong  _lbl_(rxtxmode), _lbl_(t1)                  );
                  // get bit_ticks
_dat_(            add     _lbl_(t1), #4                               );
_dat_(            rdlong  _lbl_(bitticks), _lbl_(t1)                  );
                  // get buffer_ptr
_dat_(            add     _lbl_(t1), #4                               );
_dat_(            rdlong  _lbl_(rxbuff), _lbl_(t1)                    );
_dat_(            mov     _lbl_(txbuff), _lbl_(rxbuff)                );
_dat_(            add     _lbl_(txbuff), #$10                         );
                  // init tx pin according to mode
_dat_(            test    _lbl_(rxtxmode), #4    wz                   );
_dat_(            test    _lbl_(rxtxmode), #2    wc                   );
_dat_(  if_z_ne_c or      outa, _lbl_(txmask)                         );
_dat_(  if_z      or      dira, _lbl_(txmask)                         );
                  // initialize ping-pong multitasking
_dat_(            mov     _lbl_(txcode), #(_lbl_(transmit)/4)         );
_dat_(  receive:                                                      );
                  //
                  //
                  // Receive
                  //
                  // run chunk of tx code, then return
_dat_(            jmpret  _lbl_(rxcode), _lbl_(txcode)                );
                  // wait for start bit on rx pin
_dat_(            test    _lbl_(rxtxmode), #1    wz                   );
_dat_(            test    _lbl_(rxmask), ina    wc                    );
_dat_(  if_z_eq_c jmp     #_lbl_(receive)                             );
                  // ready to receive byte
_dat_(            mov     _lbl_(rxbits), #9                           );
_dat_(            mov     _lbl_(rxcnt), _lbl_(bitticks)               );
_dat_(            shr     _lbl_(rxcnt), #1                            );
_dat_(            add     _lbl_(rxcnt), cnt                           );
_dat_(  Receive_bit:                                                  );
                  // ready next bit period
_dat_(            add     _lbl_(rxcnt), _lbl_(bitticks)               );
_dat_(  Receive_wait:                                                 );
                  // run chunk of tx code, then return
_dat_(            jmpret  _lbl_(rxcode), _lbl_(txcode)                );
                  // check if bit receive period done
_dat_(            mov     _lbl_(t1), _lbl_(rxcnt)                     );
_dat_(            sub     _lbl_(t1), cnt                              );
_dat_(            cmps    _lbl_(t1), #0    wc                         );
_dat_(  if_nc     jmp     #_lbl_(Receive_wait)                        );
                  // receive bit on rx pin
_dat_(            test    _lbl_(rxmask), ina    wc                    );
_dat_(            rcr     _lbl_(rxdata), #1                           );
_dat_(            djnz    _lbl_(rxbits), #_lbl_(Receive_bit)          );
                  // justify and trim received byte
_dat_(            shr     _lbl_(rxdata), #($20 - 9)                   );
_dat_(            and     _lbl_(rxdata), #$ff                         );
                  // if rx inverted, invert byte
_dat_(            test    _lbl_(rxtxmode), #1    wz                   );
_dat_(  if_nz     xor     _lbl_(rxdata), #$ff                         );
                  // save received byte and inc head
_dat_(            rdlong  _lbl_(t2), par                              );
_dat_(            add     _lbl_(t2), _lbl_(rxbuff)                    );
_dat_(            wrbyte  _lbl_(rxdata), _lbl_(t2)                    );
_dat_(            sub     _lbl_(t2), _lbl_(rxbuff)                    );
_dat_(            add     _lbl_(t2), #1                               );
_dat_(            and     _lbl_(t2), #$f                              );
_dat_(            wrlong  _lbl_(t2), par                              );
                  // byte done, receive next byte
_dat_(            jmp     #_lbl_(receive)                             );
_dat_(  transmit:                                                     );
                  //
                  //
                  // Transmit
                  //
                  // run chunk of rx code, then return
_dat_(            jmpret  _lbl_(txcode), _lbl_(rxcode)                );
                  // check for head <> tail
_dat_(            mov     _lbl_(t1), par                              );
_dat_(            add     _lbl_(t1), #(2 << 2)                        );
_dat_(            rdlong  _lbl_(t2), _lbl_(t1)                        );
_dat_(            add     _lbl_(t1), #(1 << 2)                        );
_dat_(            rdlong  _lbl_(t3), _lbl_(t1)                        );
_dat_(            cmp     _lbl_(t2), _lbl_(t3)    wz                  );
_dat_(  if_z      jmp     #_lbl_(transmit)                            );
                  // get byte and inc tail
_dat_(            add     _lbl_(t3), _lbl_(txbuff)                    );
_dat_(            rdbyte  _lbl_(txdata), _lbl_(t3)                    );
_dat_(            sub     _lbl_(t3), _lbl_(txbuff)                    );
_dat_(            add     _lbl_(t3), #1                               );
_dat_(            and     _lbl_(t3), #$f                              );
_dat_(            wrlong  _lbl_(t3), _lbl_(t1)                        );
                  // ready byte to transmit
_dat_(            or      _lbl_(txdata), #$100                        );
_dat_(            shl     _lbl_(txdata), #2                           );
_dat_(            or      _lbl_(txdata), #1                           );
_dat_(            mov     _lbl_(txbits), #$b                          );
_dat_(            mov     _lbl_(txcnt), cnt                           );
_dat_(  Transmit_bit:                                                 );
                  // output bit on tx pin 
_dat_(            test    _lbl_(rxtxmode), #4    wz                   );
                  // according to mode
_dat_(            test    _lbl_(rxtxmode), #2    wc                   );
_dat_(  if_z_and_c xor     _lbl_(txdata), #1                          );
_dat_(            shr     _lbl_(txdata), #1    wc                     );
_dat_(  if_z      muxc    outa, _lbl_(txmask)                         );
_dat_(  if_nz     muxnc   dira, _lbl_(txmask)                         );
                  // ready next cnt
_dat_(            add     _lbl_(txcnt), _lbl_(bitticks)               );
_dat_(  Transmit_wait:                                                );
                  // run chunk of rx code, then return
_dat_(            jmpret  _lbl_(txcode), _lbl_(rxcode)                );
                  // check if bit transmit period done
_dat_(            mov     _lbl_(t1), _lbl_(txcnt)                     );
_dat_(            sub     _lbl_(t1), cnt                              );
_dat_(            cmps    _lbl_(t1), #0    wc                         );
_dat_(  if_nc     jmp     #_lbl_(Transmit_wait)                       );
                  // another bit to transmit?
_dat_(            djnz    _lbl_(txbits), #_lbl_(Transmit_bit)         );
                  // byte done, transmit next byte
_dat_(            jmp     #_lbl_(transmit)                            );
_dat_(  t1:                                                           );
                  //
                  //
                  // Uninitialized data
                  //
_dat_(            .res    1                                           );
_dat_(  t2:                                                           );
_dat_(            .res    1                                           );
_dat_(  t3:                                                           );
_dat_(            .res    1                                           );
_dat_(  rxtxmode:                                                     );
_dat_(            .res    1                                           );
_dat_(  bitticks:                                                     );
_dat_(            .res    1                                           );
_dat_(  rxmask:                                                       );
_dat_(            .res    1                                           );
_dat_(  rxbuff:                                                       );
_dat_(            .res    1                                           );
_dat_(  rxdata:                                                       );
_dat_(            .res    1                                           );
_dat_(  rxbits:                                                       );
_dat_(            .res    1                                           );
_dat_(  rxcnt:                                                        );
_dat_(            .res    1                                           );
_dat_(  rxcode:                                                       );
_dat_(            .res    1                                           );
_dat_(  txmask:                                                       );
_dat_(            .res    1                                           );
_dat_(  txbuff:                                                       );
_dat_(            .res    1                                           );
_dat_(  txdata:                                                       );
_dat_(            .res    1                                           );
_dat_(  txbits:                                                       );
_dat_(            .res    1                                           );
_dat_(  txcnt:                                                        );
_dat_(            .res    1                                           );
_dat_(  txcode:                                                       );
_dat_(            .res    1                                           );
//
// due to a gas bug, we need the .org constants to be unknown during the first pass
// so they have to be defined here, after all asm is done
//
_dat_(  .equ ..org0001, ..org0001_base                                );
_dat_(            .compress default                                   );
_dat_(            .text                                               );

int32_t PST_Driver::start(void)
{
  int32_t 	rxpin, txpin, mode, baudrate, countdown;
  int32_t okay = 0;
  // Starts serial driver in a new cog
  rxpin = 31;
  txpin = 30;
  mode = 0;
  baudrate = 115200;
  stop();
  memset( (void *)(&rx_head), 0, sizeof(int32_t)*4);
  rx_pin = rxpin;
  tx_pin = txpin;
  rxtx_mode = mode;
  bit_ticks = CLKFREQ / baudrate;
  buffer_ptr = (int32_t)(rx_buffer);
  okay = cog = cognew((int32_t)(entry), (int32_t)(&rx_head)) + 1;
  for(countdown = 4; countdown != 0; --countdown) {
    // Give the user time to open and enable the PST program
    // after downloading the Propeller program 
    ClearHome();
    str((int32_t)"The PST interface will start in ");
    dec(countdown);
    str((int32_t)" seconds.");
    _waitcnt(CLKFREQ + CNT);
  }
  ClearHome();
  return okay;
}

void PST_Driver::StartOnCog(int32_t cognumber)
{
  int32_t 	rxpin, txpin, mode, baudrate, countdown;
  // Starts serial driver in a new cog
  cog = cognumber;
  rxpin = 31;
  txpin = 30;
  mode = 0;
  baudrate = 115200;
  // Stops
  __builtin_propeller_cogstop(cog);
  // Wipe any pre-existing receive data
  memset( (void *)(&rx_head), 0, sizeof(int32_t)*4);
  // Copy {rxpin,txpin,mode} to {rx_pin,tx_pin,rxtx_mode}
  rx_pin = rxpin;
  tx_pin = txpin;
  rxtx_mode = mode;
  // Set baudrate to 115,200 bits per second
  bit_ticks = CLKFREQ / baudrate;
  // Store receive buffer pointer address
  buffer_ptr = (int32_t)(rx_buffer);
  coginit(cog, (int32_t)(entry), (int32_t)(&rx_head));
  for(countdown = 4; countdown != 0; --countdown) {
    // Give the user time to open and enable the PST program
    // after downloading the Propeller program 
    ClearHome();
    str((int32_t)"The PST interface will start in ");
    dec(countdown);
    str((int32_t)" seconds.");
    _waitcnt(CLKFREQ + CNT);
  }
  ClearHome();
}

void PST_Driver::stop(void)
{
  int32_t 	_tmp__0003;
  if (cog) {
    // Stops serial driver - frees a cog                         
    __builtin_propeller_cogstop(( ( (_tmp__0003 = cog), (cog = 0) ), _tmp__0003 ) - 1);
  }
  memset( (void *)(&rx_head), 0, sizeof(int32_t)*9);
}

void PST_Driver::ClearHome(void)
{
  // Clears the screen and sets cursor to its home position    
  tx(PST_DRIVER_CLS);
  tx(PST_DRIVER_HOME);
}

void PST_Driver::ClearRight(void)
{
  // Clears everything to the right of the cursor              
  tx(PST_DRIVER_CLREOL);
}

void PST_Driver::NewLine(void)
{
  // Creates a new line and moves cursor to the far left              
  tx(PST_DRIVER_CR);
}

void PST_Driver::NewLines(int32_t number)
{
  int32_t 	_idx__0004, _limit__0005;
  for(( (_idx__0004 = 0), (_limit__0005 = number) ); _idx__0004 < _limit__0005; _idx__0004++) {
    // Carriage return (moves cursor to the far left)                                                                
    tx(PST_DRIVER_CR);
  }
}

void PST_Driver::SetCursorHome(void)
{
  // Moves the cursor to the upper left of the screen          
  tx(PST_DRIVER_HOME);
}

void PST_Driver::SetCursor(int32_t column, int32_t row)
{
  // Moves the cursor to a specific position                   
  tx(PST_DRIVER_CRSRXY);
  tx(column);
  tx(row);
}

void PST_Driver::str(int32_t stringptr)
{
  int32_t 	_idx__0006, _limit__0007;
  // Send zero terminated string that starts at the 
  for(( (_idx__0006 = 0), (_limit__0007 = strlen((const char *)stringptr)) ); _idx__0006 < _limit__0007; _idx__0006++) {
    tx(((char *)(stringptr++))[0]);
  }
}

void PST_Driver::strcr(int32_t stringptr)
{
  int32_t 	_idx__0008, _limit__0009;
  // Send zero terminated string that starts at the 
  for(( (_idx__0008 = 0), (_limit__0009 = strlen((const char *)stringptr)) ); _idx__0008 < _limit__0009; _idx__0008++) {
    tx(((char *)(stringptr++))[0]);
  }
  tx(PST_DRIVER_CR);
}

int32_t PST_Driver::dec(int32_t value)
{
  int32_t 	i, _idx__0010;
  int32_t result = 0;
  // Prints a decimal number 
  if (value < 0) {
    value = -value;
    tx('-');
  }
  i = 1000000000;
  for(_idx__0010 = 0; _idx__0010 < 10; _idx__0010++) {
    if (value >= i) {
      // "0"=48 and 48+(a # 0-9)=the ASCII character value for that #
      tx((value / i) + '0');
      value = value % i;
      result = -1;
    } else {
      if ((result) || (i == 1)) {
        tx('0');
      }
    }
    i = i / 10;
  }
  ClearRight();
  return result;
}

// NewLine
int32_t PST_Driver::decNCR(int32_t value)
{
  int32_t 	i, _idx__0011;
  int32_t result = 0;
  // Prints a decimal number without a creating a new line afterward
  if (value < 0) {
    value = -value;
    tx('-');
  }
  i = 1000000000;
  for(_idx__0011 = 0; _idx__0011 < 10; _idx__0011++) {
    if (value >= i) {
      // "0"=48 and 48+(a # 0-9)=the ASCII character value for that #
      tx((value / i) + '0');
      value = value % i;
      result = -1;
    } else {
      if ((result) || (i == 1)) {
        tx('0');
      }
    }
    i = i / 10;
  }
  ClearRight();
  return result;
}

int32_t PST_Driver::GetDec(void)
{
  int32_t _local__0012[11];
  int32_t value = 0;
  // Gets decimal character representation of a number from the terminal           
  // and returns the corresponding value                                          
  getstr((int32_t)(_local__0012[0]));
  value = StrToDec((int32_t)(_local__0012[0]));
  return value;
}

int32_t PST_Driver::StrToDec(int32_t stringptr)
{
  int32_t 	character, index, multiply;
  int32_t value = 0;
  // Converts a zero terminated string representation of a decimal number to a value
  value = index = 0;
  while (!((character = ((char *)stringptr)[(index++)]) == 0)) {
    if ((character >= '0') && (character <= '9')) {
      value = (value * 10) + (character - '0');
    }
  }
  if (((char *)stringptr)[0] == '-') {
    value = -value;
  }
  return value;
}

void PST_Driver::bin(int32_t value, int32_t digits)
{
  int32_t 	_idx__0013, _limit__0014;
  // Sends the character representation of a binary number to the terminal.
  value = value << (32 - digits);
  for(( (_idx__0013 = 0), (_limit__0014 = digits) ); _idx__0013 < _limit__0014; _idx__0013++) {
    tx(((value = Rotl__(value, 1)) & 0x1) + '0');
  }
}

int32_t PST_Driver::GetBin(void)
{
  int32_t _local__0015[11];
  int32_t value = 0;
  // Gets binary character representation of a number from the terminal and returns the corresponding value
  getstr((int32_t)(_local__0015[0]));
  value = StrToBin((int32_t)(_local__0015[0]));
  return value;
}

int32_t PST_Driver::StrToBin(int32_t stringptr)
{
  int32_t 	character, index;
  int32_t value = 0;
  // Converts a zero terminated string representaton of a binary number to a value
  value = index = 0;
  while (!((character = ((char *)stringptr)[(index++)]) == 0)) {
    if ((character == '0') || (character == '1')) {
      // "0"=48, "1"=49 
      //
      value = (value * 2) + (character - '0');
    }
  }
  if (((char *)stringptr)[0] == '-') {
    value = -value;
  }
  return value;
}

int32_t PST_Driver::GetFloat(void)
{
  int32_t _local__0016[11];
  int32_t value = 0;
  // Gets a floating point number from the PST (ex. 3.14159HELPIMTRAPPEDINAUNIVERSEFACTORY9302)                                                                      
  getstr((int32_t)(_local__0016[0]));
  // Returns value in IEEE 754 float point
  value = StrToFloat((int32_t)(_local__0016[0]));
  return value;
}

int32_t PST_Driver::StrToFloat(int32_t strptr)
{
  int32_t 	Int, exp, sign, _tmp__0017, _idx__0018, _limit__0019, _idx__0020, _limit__0021;
  int32_t flt = 0;
  // Converts an input string in the from XX.XX (with an integer, decimal point, and fraction part)
  // into a floating point number
  // This code was borrowed from http://forums.parallax.com/forums/default.aspx?f=25&m=280607 (11/21/2008)
  Int = exp = sign = 0;
  for(( (_idx__0018 = 0), (_limit__0019 = strlen((const char *)strptr)) ); _idx__0018 < _limit__0019; _idx__0018++) {
    // string to integer
    _tmp__0017 = ((char *)strptr)[0];
     if (_tmp__0017 == '-') {
      sign = -1;
    } else if (_tmp__0017 == '.') {
      exp = 1;
    } else if (('0' <= _tmp__0017) && (_tmp__0017 <= '9')) {
      Int = ((Int * 10) + ((char *)strptr)[0]) - '0';
      if (exp) {
        // count dec places
        (exp++);
      }
    } else if (1) {
      break;
    }
    (strptr++);
  }
  if (sign) {
    Int = -Int;
  }
  flt = FFloat(Int);
  if (exp) {
    for(( (_idx__0020 = 0), (_limit__0021 = exp - 1) ); _idx__0020 < _limit__0021; _idx__0020++) {
      // adjust float
      flt = FDiv(flt, 0x41200000);
    }
  }
  return flt;
}

void PST_Driver::Char(int32_t bytechr)
{
  // This method was borrowed directly from the "Parallax Serial Terminal Plus" object
  // Send single-byte character.  Waits for room in transmit buffer if necessary.
  /*  
    Parameter:
      bytechr - character (ASCII byte value)
                to send.
    Examples:
      'Send "A" to Parallax Serial Terminal
      pst.Char("A")
      'Send "A" to Parallax Serial Terminal
      'using its ASCII value
      pst.Char(65)              
    
   */
  if (!(cog)) {
    start();
  }
  while (!(tx_tail != ((tx_head + 1) & 0x3f))) {
    Yield__();
  }
  tx_buffer[tx_head] = bytechr;
  tx_head = (tx_head + 1) & 0x3f;
  if (rxtx_mode & 0x8) {
    CharIn();
  }
}

int32_t PST_Driver::CharIn(void)
{
  int32_t bytechr = 0;
  // This method was borrowed directly from the "Parallax Serial Terminal Plus" object
  // Send single-byte character.  Waits for room in transmit buffer if necessary.
  /* Returns:
      A byte value (0 to 255) which
      represents a character that has been typed 
      into the Parallax Serial Terminal.
     
    Example:
      ' Get a character that is typed into the
      ' Parallax Serial Terminal, and copy it to
      ' a variable named c.
      c := pst.CharIn
    
   */
  if (!(cog)) {
    start();
  }
  while ((bytechr = rxcheck()) < 0) {
    Yield__();
  }
  return bytechr;
}

void PST_Driver::tx(int32_t txbyte)
{
  // Sends byte (may wait for room in buffer)
  while (!(tx_tail != ((tx_head + 1) & 0xf))) {
    Yield__();
  }
  tx_buffer[tx_head] = txbyte;
  tx_head = (tx_head + 1) & 0xf;
  if (rxtx_mode & 0x8) {
    rx();
  }
}

int32_t PST_Driver::rx(void)
{
  int32_t rxbyte = 0;
  // Receives byte (may wait for byte)
  while ((rxbyte = rxcheck()) < 0) {
    Yield__();
  }
  return rxbyte;
}

// rxbyte returns $00..$FF
void PST_Driver::rxflush(void)
{
  // Flush receive buffer 
  while (rxcheck() >= 0) {
    Yield__();
  }
}

int32_t PST_Driver::rxcheck(void)
{
  int32_t rxbyte = 0;
  // Check if byte received (never waits) 
  // rxbyte returns -1 if no byte received, $00..$FF if byte
  (rxbyte--);
  if (rx_tail != rx_head) {
    rxbyte = rx_buffer[rx_tail];
    rx_tail = (rx_tail + 1) & 0xf;
  }
  return rxbyte;
}

int32_t PST_Driver::rxtime(int32_t ms)
{
  int32_t 	t;
  int32_t rxbyte = 0;
  // Wait ms milliseconds for a byte to be received
  // returns -1 if no byte received, $00..$FF if byte 
  t = CNT;
  while (!(((rxbyte = rxcheck()) >= 0) || (((CNT - t) / (CLKFREQ / 1000)) > ms))) {
    Yield__();
  }
  return rxbyte;
}

void PST_Driver::getstr(int32_t stringptr)
{
  int32_t 	index;
  // Gets zero terminated string and stores it, starting at the stringptr memory address             
  index = 0;
  while (!((((char *)stringptr)[(index++)] = rx()) == PST_DRIVER_CR)) {
    // CR=Carriage Return=13 (Enter key)                                            
    if (((char *)stringptr)[index] == PST_DRIVER_BKSP) {
      // BKSP=8=Backspace (Backspace key)                                              
      (index--);
    }
  }
  ((char *)stringptr)[(--index)] = 0;
}

void PST_Driver::hex(int32_t value, int32_t digits)
{
  int32_t 	_idx__0022, _limit__0023;
  static int32_t look__0030[] = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, };

  // Prints a hexadecimal number
  value = value << ((8 - digits) << 2);
  for(( (_idx__0022 = 0), (_limit__0023 = digits) ); _idx__0022 < _limit__0023; _idx__0022++) {
    tx(Lookup__(((value = Rotl__(value, 4)) & 0xf), 0, look__0030, 16));
  }
}

int32_t PST_Driver::GetHex(void)
{
  int32_t _local__0024[11];
  int32_t value = 0;
  // Gets hexadecimal character representation of a number from the terminal and returns the corresponding value                                                                                   
  getstr((int32_t)(_local__0024[0]));
  value = StrToHex((int32_t)(_local__0024[0]));
  return value;
}

int32_t PST_Driver::StrToHex(int32_t stringptr)
{
  int32_t 	character, index;
  int32_t value = 0;
  // Converts a zero terminated string representaton of a hexadecimal number to a value                                                                                          
  value = index = 0;
  while (!((character = ((char *)stringptr)[(index++)]) == 0)) {
    if ((character >= '0') && (character <= '9')) {
      value = (value * 16) + (character - '0');
    } else {
      if ((character >= 'A') && (character <= 'F')) {
        value = (value * 16) + ((10 + character) - 'A');
      } else {
        if ((character >= 'a') && (character <= 'f')) {
          value = (value * 16) + ((10 + character) - 'a');
        }
      }
    }
  }
  if (((char *)stringptr)[0] == '-') {
    value = -value;
  }
  return value;
}

int32_t PST_Driver::FFloat(int32_t integer)
{
  int32_t _local__0025[3];
  // Converts an integer number to a floating-point-formatted number
  if ((_local__0025[2] = abs(integer))) {
    // absolutize mantissa, if 0, result 0
    // get sign
    _local__0025[0] = Shr__(integer, 31);
    // get exponent
    _local__0025[1] = (BitEncode__(_local__0025[2])) - 1;
    // msb-justify mantissa
    _local__0025[2] = _local__0025[2] << (31 - _local__0025[1]);
    // bit29-justify mantissa
    _local__0025[2] = Shr__(_local__0025[2], 2);
    // pack result
    return Pack((int32_t)(&_local__0025[0]));
  }
  return 0;
}

int32_t PST_Driver::FDiv(int32_t singleA, int32_t singleB)
{
  int32_t _local__0027[7];
  int32_t single = 0;
  // Divide singleA by singleB (which are two floating-point values)
  // unpack inputs
  Unpack((int32_t)(&_local__0027[0]), singleA);
  Unpack((int32_t)(&_local__0027[3]), singleB);
  // xor signs
  _local__0027[0] ^= _local__0027[3];
  // subtract exponents
  _local__0027[1] = _local__0027[1] - _local__0027[4];
  for(_local__0027[6] = 0; _local__0027[6] < 30; _local__0027[6]++) {
    single = single << 1;
    if (_local__0027[2] >= _local__0027[5]) {
      _local__0027[2] = _local__0027[2] - _local__0027[5];
      (single++);
    }
    _local__0027[2] = _local__0027[2] << 1;
  }
  _local__0027[2] = single;
  // pack result
  return Pack((int32_t)(&_local__0027[0]));
}

int32_t PST_Driver::Pack(int32_t pointer)
{
  int32_t _local__0028[3];
  int32_t single = 0;
  // Pack floating-point from (sign, exponent, mantissa) at pointer
  // get (s,x,m) structure into locals
  memmove( (void *)&_local__0028[0], (void *)pointer, 4*(3));
  if (_local__0028[2]) {
    // determine magnitude of mantissa
    single = 33 - (BitEncode__(_local__0028[2]));
    // msb-justify mantissa without leading 1
    _local__0028[2] = _local__0028[2] << single;
    // adjust exponent
    _local__0028[1] = _local__0028[1] + (3 - single);
    // round up mantissa by 1/2 lsb
    _local__0028[2] = _local__0028[2] + 256;
    if (-(!_local__0028[2]) & 0xffffff00) {
      // if rounding overflow,
      // ..increment exponent
      (_local__0028[1]++);
    }
    // bias and limit exponent
    _local__0028[1] = Min__((Max__((_local__0028[1] + 127), (-23))), 255);
    if (_local__0028[1] < 1) {
      // if exponent < 1,
      // ..replace leading 1
      _local__0028[2] = (int32_t)0x80000000U + (Shr__(_local__0028[2], 1));
      // ..shift mantissa down by exponent
      _local__0028[2] = Shr__(_local__0028[2], (-_local__0028[1]));
      // ..exponent is now 0
      _local__0028[1] = 0;
    }
    // pack result
    return (((_local__0028[0] << 31) | (_local__0028[1] << 23)) | (Shr__(_local__0028[2], 9)));
  }
  return single;
}

int32_t PST_Driver::Unpack(int32_t pointer, int32_t single)
{
  int32_t _local__0029[3];
  int32_t result = 0;
  // Unpack floating-point into (sign, exponent, mantissa) at pointer
  // unpack sign
  _local__0029[0] = Shr__(single, 31);
  // unpack exponent
  _local__0029[1] = Shr__((single << 1), 24);
  // unpack mantissa
  _local__0029[2] = single & 0x7fffff;
  if (_local__0029[1]) {
    // if exponent > 0,
    // ..bit29-justify mantissa with leading 1
    _local__0029[2] = (_local__0029[2] << 6) | 0x20000000;
  } else {
    // else, determine first 1 in mantissa
    result = (BitEncode__(_local__0029[2])) - 23;
    // ..adjust exponent
    _local__0029[1] = result;
    // ..bit29-justify mantissa
    _local__0029[2] = _local__0029[2] << (7 - result);
  }
  // unbias exponent
  _local__0029[1] = _local__0029[1] - 127;
  // write (s,x,m) structure from locals
  memmove( (void *)pointer, (void *)&_local__0029[0], 4*(3));
  return result;
}

/* 
┌──────────────────────────────────────────────────────────────────────────────────────┐
│                           TERMS OF USE: MIT License                                  │                                                            
├──────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this  │
│software and associated documentation files (the "Software"), to deal in the Software │ 
│without restriction, including without limitation the rights to use, copy, modify,    │
│merge, publish, distribute, sublicense, and/or sell copies of the Software, and to    │
│permit persons to whom the Software is furnished to do so, subject to the following   │
│conditions:                                                                           │                                            │
│                                                                                      │                                               │
│The above copyright notice and this permission notice shall be included in all copies │
│or substantial portions of the Software.                                              │
│                                                                                      │                                                │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,   │
│INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A         │
│PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT    │
│HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION     │
│OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE        │
│SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                                │
└──────────────────────────────────────────────────────────────────────────────────────┘
 */
